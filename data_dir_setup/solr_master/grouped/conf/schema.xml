<?xml version="1.0" ?>
<schema name="Pika Grouped Work Index" version="1.6">
	<!-- attribute "name" is the name of this schema and is only used for display purposes.
	   version="x.y" is Solr's version number for the schema syntax and
	   semantics.  It should not normally be changed by applications.

	   1.0: multiValued attribute did not exist, all fields are multiValued
			by nature
	   1.1: multiValued attribute introduced, false by default
	   1.2: omitTermFreqAndPositions attribute introduced, true by default
			except for text fields.
	   1.3: removed optional field compress feature
	   1.4: autoGeneratePhraseQueries attribute introduced to drive QueryParser
			behavior when a single string produces multiple tokens.  Defaults
			to off for version >= 1.4
	   1.5: omitNorms defaults to true for primitive field types
			(int, float, boolean, string...)
	   1.6: useDocValuesAsStored defaults to true.
	-->

	<types>
		<!-- Valid attributes for fields:
		 name: mandatory - the name for the field
		 type: mandatory - the name of a field type from the
		   fieldTypes section
		 indexed: true if this field should be indexed (searchable or sortable)
		 stored: true if this field should be retrievable
		 docValues: true if this field should have doc values. Doc Values is
		   recommended (required, if you are using *Point fields) for faceting,
		   grouping, sorting and function queries. Doc Values will make the index
		   faster to load, more NRT-friendly and more memory-efficient.
		   They are currently only supported by StrField, UUIDField, all
		   *PointFields, and depending on the field type, they might require
		   the field to be single-valued, be required or have a default value
		   (check the documentation of the field type you're interested in for
		   more information)
		 multiValued: true if this field may contain multiple values per document
		 omitNorms: (expert) set to true to omit the norms associated with
		   this field (this disables length normalization and index-time
		   boosting for the field, and saves some memory).  Only full-text
		   fields or fields that need an index-time boost need norms.
		   Norms are omitted for primitive (non-analyzed) types by default.
		 termVectors: [false] set to true to store the term vector for a
		   given field.
		   When using MoreLikeThis, fields used for similarity should be
		   stored for best performance.
		 termPositions: Store position information with the term vector.
		   This will increase storage costs.
		 termOffsets: Store offset information with the term vector. This
		   will increase storage costs.
		 required: The field is required.  It will throw an error if the
		   value does not exist
		 default: a value that should be used if no value is specified
		   when adding a document.
		-->

		<!-- field names should consist of alphanumeric or underscore characters only and
		  not start with a digit.  This is not currently strictly enforced,
		  but other field names will not have first class support from all components
		  and back compatibility is not guaranteed.  Names with both leading and
		  trailing underscores (e.g. _version_) are reserved.
		-->

		<fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true" docValues="true"/>
		<fieldType name="integer" class="solr.IntPointField" omitNorms="true" docValues="true"/>
		<fieldType name="float" class="solr.FloatPointField" omitNorms="true" docValues="true"/>
		<fieldType name="long" class="solr.LongPointField" positionIncrementGap="0" docValues="true"/>
		<fieldType name="date" class="solr.DatePointField" docValues="true"/>
		<fieldType name="text" class="solr.TextField" positionIncrementGap="100">
			<analyzer>
				<!-- Whitespace tokenizer is needed so the Word Delimiter filter factory works properly
				 For example, this allows E.T. The Extra-Terrestrial to be handled properly.  #ARL-168
				-->
				<tokenizer class="solr.WhitespaceTokenizerFactory"/>
				<filter class="solr.WordDelimiterGraphFilterFactory"
						generateWordParts="1"
						generateNumberParts="1"
						splitOnCaseChange="1"
						catenateAll="0"
						stemEnglishPossessive="1"

						catenateWords="1"
						catenateNumbers="1"
						splitOnNumerics="0"
				/>
				<!--
				// Turn off splitOnNumerics Pascal 7/19/21 tokenizes Ids like ".b1234x" into "b","1234,"x"   See D-3984

				From documentation : https://solr.apache.org/guide/8_8/filter-descriptions.html#word-delimiter-graph-filter

									generateWordParts
						(integer, default 1) If non-zero, splits words at delimiters. For example:"CamelCase", "hot-spot" -> "Camel", "Case", "hot", "spot"
					generateNumberParts
						(integer, default 1) If non-zero, splits numeric strings at delimiters:"1947-32" ->*"1947", "32"
					splitOnCaseChange
						(integer, default 1) If 0, words are not split on camel-case changes:"BugBlaster-XL" -> "BugBlaster", "XL". Example 1 below illustrates the default (non-zero) splitting behavior.
					splitOnNumerics
						(integer, default 1) If 0, don’t split words on transitions from alpha to numeric:"FemBot3000" -> "Fem", "Bot3000"
					catenateWords
						(integer, default 0) If non-zero, maximal runs of word parts will be joined: "hot-spot-sensor’s" -> "hotspotsensor"
					catenateNumbers
						(integer, default 0) If non-zero, maximal runs of number parts will be joined: 1947-32" -> "194732"
					catenateAll
						(0/1, default 0) If non-zero, runs of word and number parts will be joined: "Zap-Master-9000" -> "ZapMaster9000"
					preserveOriginal
						(integer, default 0) If non-zero, the original token is preserved: "Zap-Master-9000" -> "Zap-Master-9000", "Zap", "Master", "9000"
					protected
						(optional) The pathname of a file that contains a list of protected words that should be passed through without splitting.
					stemEnglishPossessive
						(integer, default 1) If 1, strips the possessive 's from each subword.
				-->
				<filter class="solr.SynonymGraphFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
				<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
				<filter class="solr.ICUFoldingFilterFactory"/>
				<!-- ICU Tokenizer requires additional library to be added in the core's /lib folder to work.
				  https://lucene.apache.org/solr/guide/7_7/tokenizers.html#tokenizers
				  -->
				<filter class="solr.CommonGramsFilterFactory" words="stopwords.txt" ignoreCase="true"/>
				<filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
				<filter class="solr.SnowballPorterFilterFactory" language="English"/>
				<filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
			</analyzer>
		</fieldType>
		<!-- Text Field without Stemming, Synonyms, and stop Word removal -->
		<fieldType name="textProper" class="solr.TextField" positionIncrementGap="100">
			<analyzer>
				<tokenizer class="solr.ICUTokenizerFactory"/>
				<filter class="solr.WordDelimiterGraphFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1" splitOnNumerics="0" stemEnglishPossessive="1"/>
				<filter class="solr.ICUFoldingFilterFactory"/>
				<filter class="solr.CommonGramsFilterFactory" words="stopwords.txt" ignoreCase="true"/>
				<filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
			</analyzer>
		</fieldType>
		<!-- This is an example of using the KeywordTokenizer along
		 With various TokenFilterFactories to produce a sortable field
		 that does not include some properties of the source text
	  -->
		<fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
			<analyzer>
				<!-- KeywordTokenizer does no actual tokenizing, so the entire
			 input string is preserved as a single token
		  -->
				<tokenizer class="solr.KeywordTokenizerFactory"/>
				<!-- The LowerCase TokenFilter does what you expect, which can be
			 when you want your sorting to be case insensitive
		  -->
				<filter class="solr.LowerCaseFilterFactory"/>
				<!-- The TrimFilter removes any leading or trailing whitespace -->
				<filter class="solr.TrimFilterFactory"/>
				<!-- The PatternReplaceFilter gives you the flexibility to use
				 Java Regular expression to replace any sequence of characters
				 matching a pattern with an arbitrary replacement string,
				 which may include back references to portions of the original
				 string matched by the pattern.

				 See the Java Regular Expression documentation for more
				 information on pattern and replacement string syntax.

				 http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/package-summary.html
				-->
				<filter class="solr.PatternReplaceFilterFactory" pattern="([^a-z1-9\s])" replacement="" replace="all"/>
			</analyzer>
		</fieldType>
		<fieldType name="callnumber-search" class="solr.TextField" sortMissingLast="true" omitNorms="true">
			<analyzer>
				<!-- KeywordTokenizer does no actual tokenizing, so the entire
					 input string is preserved as a single token
				-->
				<tokenizer class="solr.KeywordTokenizerFactory"/>
				<filter class="solr.WordDelimiterGraphFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
				<filter class="solr.LengthFilterFactory" min="2" max="100"/>
				<!-- The LowerCase TokenFilter does what you expect, which can be
				 when you want your sorting to be case insensitive
				-->
				<filter class="solr.LowerCaseFilterFactory"/>
				<!-- The TrimFilter removes any leading or trailing whitespace -->
				<filter class="solr.TrimFilterFactory"/>
			</analyzer>
		</fieldType>
		<fieldType name="text-exact" class="solr.TextField" sortMissingLast="true" omitNorms="true">
			<analyzer>
				<!-- KeywordTokenizer does no actual tokenizing, so the entire input string is preserved as a single token -->
				<tokenizer class="solr.KeywordTokenizerFactory"/>
				<charFilter class="solr.PatternReplaceCharFilterFactory" pattern="^\s*(.*)\s*$" replacement="aaaa $1 zzzz"/>
				<filter class="solr.LowerCaseFilterFactory"/>
				<!-- The TrimFilter removes any leading or trailing whitespace -->
				<filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
			</analyzer>
		</fieldType>
		<fieldType name="text-left" class="solr.TextField" sortMissingLast="true" omitNorms="true">
			<analyzer type="index">
				<tokenizer class="solr.KeywordTokenizerFactory"/>
				<charFilter class="solr.PatternReplaceCharFilterFactory" pattern="^\s*(.*)\s*$" replacement="aaaa $1"/>
				<filter class="solr.LowerCaseFilterFactory"/>
				<!-- The TrimFilter removes any leading or trailing whitespace -->
				<filter class="solr.TrimFilterFactory"/>
				<filter class="solr.EdgeNGramFilterFactory" minGramSize="5" maxGramSize="40"/>
				<filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
			</analyzer>
			<analyzer type="query">
				<tokenizer class="solr.KeywordTokenizerFactory"/>
				<charFilter class="solr.PatternReplaceCharFilterFactory" pattern="^\s*(.*)\s*$" replacement="aaaa $1"/>
				<filter class="solr.LowerCaseFilterFactory"/>
			</analyzer>
		</fieldType>
		<fieldType name="random" class="solr.RandomSortField"/>
	</types>
	<fields>
		<field name="_version_" type="long" indexed="false" stored="false"/>
		<!-- docValues are enabled by default for long type so we don't need to index the version field  -->

		<!-- Main Id -->
		<!-- 	The solr documents id is based on the grouped work id, except for user list documents -->
		<field name="id" type="string" indexed="true" stored="true" omitNorms="true"/>
		<field name="recordtype" type="string" indexed="true" stored="true" multiValued="false" omitNorms="false"/>
		<field name="alternate_ids" type="string" indexed="true" stored="false" multiValued="true" omitNorms="true"/>
		<field name="last_indexed" type="date" indexed="false" stored="true" multiValued="false"/>

		<!-- Related Record information -->
		<field name="scope_has_related_records" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<!-- Allows us to filter out works that are not part of the end user's search scope.  -->
		<field name="record_details" type="string" indexed="false" stored="true" multiValued="true"/>
		<field name="item_details" type="string" indexed="false" stored="true" multiValued="true"/>
		<dynamicField name="scoping_details_*" type="string" indexed="false" stored="true" multiValued="true"/>

		<!-- Fields to determine ownership and location based on location codes -->
		<dynamicField name="owning_library_*" type="string" indexed="true" stored="true" multiValued="true" omitNorms="false" docValues="true"/>
		<dynamicField name="owning_location_*" type="string" indexed="true" stored="true" multiValued="true" omitNorms="false" docValues="true"/>
		<dynamicField name="detailed_location_*" type="string" indexed="true" stored="true" multiValued="true" omitNorms="true" docValues="true"/>

		<dynamicField name="collection_*" type="string" indexed="true" stored="true" multiValued="true" omitNorms="false" docValues="true"/>

		<!-- Fields to determine availability -->
		<dynamicField name="available_at_*" type="string" indexed="true" stored="true" multiValued="true" omitNorms="true" docValues="true"/>
		<dynamicField name="availability_toggle_*" type="string" indexed="true" stored="true" multiValued="true" omitNorms="true" docValues="true"/>
		<!-- Link availability and format for better FRBR display -->
		<dynamicField name="availability_by_format_*" type="string" indexed="true" stored="true" multiValued="true" omitNorms="true"/>

		<!-- Title variations -->
		<field name="title" type="text" indexed="true" stored="true"/>  <!-- basic title -->
		<field name="title_exact" type="text-exact" indexed="true" stored="true"/>  <!-- basic title -->
		<field name="title_left" type="text-left" indexed="true" stored="true"/>  <!-- basic title -->
		<field name="title_proper" type="textProper" indexed="true" stored="false"/>  <!-- basic title -->
		<field name="title_display" type="text" indexed="true" stored="true" multiValued="false"/> <!-- The title to display to the user -->
		<field name="title_sort" type="alphaOnlySort" indexed="true" stored="true"/> <!-- title for sorting -->
		<field name="title_sub" type="text" indexed="true" stored="true"/>
		<field name="title_short" type="text" indexed="true" stored="true"/>
		<field name="title_full" type="text" indexed="true" stored="true" multiValued="true"/> <!-- Title full includes the author -->
<!--		<field name="title_fullStr" type="string" indexed="true" stored="true" multiValued="true"/>-->
		<field name="title_alt" type="text" indexed="true" stored="true" multiValued="true"/>
		<!--Removing title_old and title_new for now, until we create a use. Pascal 7/20/2021 -->
<!--		<field name="title_old" type="text" indexed="true" stored="true" multiValued="true"/>-->
		<!--MARC 780 tag Preceding Entry
		$a - Main entry heading (NR)
		$s - Uniform title (NR)
		$t - Title (NR)

		Looks to be the previous title in a series
		-->
<!--		<field name="title_new" type="text" indexed="true" stored="true" multiValued="true"/>-->
		<!--MARC 785 tag Succeeding Entry
		$a - Main entry heading (NR)
		$s - Uniform title (NR)
		$t - Title (NR)

		Looks to be the next title in a series
		 -->
		<!-- Author variations -->
		<field name="author" type="text" indexed="true" stored="true" />
		<!-- First MARC tag 100abcdq or 110ab -->
		<field name="author_exact" type="text-exact" indexed="true" stored="true" />
		<field name="author_left" type="text-left" indexed="true" stored="true" />
		<field name="author_display" type="string" indexed="true" stored="true" multiValued="false"/> <!-- The title to display to the user -->
<!--		<field name="author-letter" type="string" indexed="true" stored="true"/>-->
		<!--TODO: remove author-letter from index. Can't determine what its use would be -->
		<field name="authorStr" type="string" indexed="true" stored="true" docValues="true"/>
		<field name="auth_author" type="textProper" indexed="true" stored="false"/>
		<!-- First MARC tag 100abcd -->
		<field name="auth_authorStr" type="string" indexed="true" stored="false"/>
		<field name="author2" type="text" indexed="true" stored="true" multiValued="true"/>
		<!-- All MARC tags 110ab, 111ab, 700abcd, 710ab, 711ab, and 800a -->
		<field name="author2Str" type="string" indexed="true" stored="true" multiValued="true"/>
		<field name="author2-role" type="string" indexed="true" stored="true" multiValued="true"/>
		<!-- The contributor with role and title appended -->
		<!-- All MARC tags 700abcdetmnr and 710abcdetmnr with translation of relator code (subfield 4) appended after pipe character "|" -->
		<field name="auth_author2" type="textProper" indexed="true" stored="true" multiValued="true"/>
		<!-- All MARC tags 700abcd -->
		<field name="auth_author2Str" type="string" indexed="true" stored="false" multiValued="true"/>
		<field name="author_additional" type="text" indexed="true" stored="true" multiValued="true"/>
		<!-- All MARC tags 505r and 245c -->
<!--		<field name="author_additionalStr" type="string" indexed="true" stored="false" multiValued="true"/>  Pretty sure this is redundant pascal. 7/19/21 -->

		<!-- format -->
		<field name="grouping_category" type="string" indexed="true" stored="true" multiValued="false" omitNorms="true"/>
		<!--TODO: Is there a reason to index the grouping_category ? -->
		<dynamicField name="format_*" type="string" indexed="true" stored="true" multiValued="true" omitNorms="true" docValues="true"/>
		<field name="format_boost" type="integer" indexed="true" stored="true" multiValued="false" omitNorms="true" default="1"/>
		<dynamicField name="format_category_*" type="string" indexed="true" stored="true" multiValued="true" omitNorms="true" docValues="true"/>

		<!-- Publication information -->
		<field name="publisher" type="textProper" indexed="true" stored="true" multiValued="true"/>
<!--		<field name="publisherStr" type="string" indexed="true" stored="true" multiValued="true"/> Pretty sure this is redundant pascal 11/12/20 -->
		<field name="publishDate" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<field name="publishDateSort" type="string" indexed="true" stored="true"/>
		<field name="edition" type="string" indexed="true" stored="true" multiValued="true"/>
		<field name="dateSpan" type="string" indexed="true" stored="true" multiValued="true"/>
			<!--field for MARC 362a Dates of Publication and/or Sequential Designation  -->

		<!-- Things for faceting and refined searching -->
		<field name="physical" type="string" indexed="true" stored="true" multiValued="true"/>

		<!-- series -->
		<field name="series" type="text" indexed="true" stored="true" multiValued="true"/>
		<field name="series2" type="text" indexed="true" stored="true" multiValued="true"/>
		<!--TODO: is series2 really needed?? -->
		<field name="series_proper" type="textProper" indexed="true" stored="false" multiValued="true"/>
		<field name="series_with_volume" type="textProper" indexed="false" stored="true" multiValued="true"/>

		<!-- subject facets-->
		<field name="subject_facet" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<field name="subject" type="text" indexed="true" stored="true" multiValued="true"/>
		<field name="subject_proper" type="textProper" indexed="true" stored="false" multiValued="true"/>
		<field name="topic" type="text" indexed="true" stored="true" multiValued="true"/>
		<field name="topic_proper" type="textProper" indexed="true" stored="false" multiValued="true"/>
		<field name="topic_facet" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<field name="lc_subject" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<field name="bisac_subject" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<field name="genre" type="text" indexed="true" stored="true" multiValued="true"/>
		<field name="genre_proper" type="textProper" indexed="true" stored="false" multiValued="true"/>
		<field name="genre_facet" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<field name="geographic" type="text" indexed="true" stored="true" multiValued="true"/>
		<field name="geographic_proper" type="textProper" indexed="true" stored="false" multiValued="true"/>
		<field name="geographic_facet" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<field name="era" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<field name="era_proper" type="textProper" indexed="true" stored="false" multiValued="true"/>

		<field name="literary_form_full" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<!-- Detailed version of the literary form. Typically consists of values: Non Fiction, Fiction, Dramas,
			Essays, Novels, Humor, Satires, etc., Letters, Short Stories, Mixed Forms, Poetry, Speeches, Unknown,
			Not Coded-->
		<field name="literary_form" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<!--simple version of literary form. Consists of values: Fiction, Non Fiction, Unknown, Not Coded -->

		<!-- audience -->
		<field name="target_audience_full" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<field name="target_audience" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>

		<!-- when added to the catalog -->
		<field name="date_added" type="date" indexed="true" stored="true" multiValued="false"/>
		<field name="time_since_added" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<field name="days_since_added" type="integer" indexed="true" stored="true" multiValued="false"/>
		<dynamicField name="local_time_since_added_*" type="string" indexed="true" stored="true" multiValued="true"/>
		<dynamicField name="local_days_since_added_*" type="integer" indexed="true" stored="true" multiValued="false"/>

		<dynamicField name="itype_*" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<field name="barcode" type="string" indexed="true" stored="false" multiValued="true"/>

		<!-- awards and ratings -->
		<field name="mpaa_rating" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<field name="awards_facet" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>

		<!--Reading level data -->
		<field name="lexile_score" type="integer" indexed="true" stored="true" multiValued="false" default="-1" docValues="true"/>
		<field name="lexile_code" type="string" indexed="true" stored="true" multiValued="false" docValues="true"/>
		<field name="fountas_pinnell" type="string" indexed="true" stored="true" multiValued="false" docValues="true"/>
		<field name="accelerated_reader_interest_level" type="string" indexed="true" stored="true" multiValued="false" docValues="true"/>
		<field name="accelerated_reader_reading_level" type="float" indexed="true" stored="true" multiValued="false" default="0" docValues="true"/>
		<field name="accelerated_reader_point_value" type="float" indexed="true" stored="true" multiValued="false" default="0" docValues="true"/>

		<!-- eContent related fields -->
		<field name="econtent_device" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
			<!--TODO: remove-->
		<dynamicField name="econtent_source_*" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>

		<!-- Broad Search Terms -->
		<field name="table_of_contents" type="text" indexed="true" stored="true" multiValued="true"/>
		<field name="table_of_contents_proper" type="textProper" indexed="true" stored="true" multiValued="true"/>
		<field name="keywords" type="text" indexed="true" stored="false"/>
		<field name="keywords_proper" type="textProper" indexed="true" stored="false"/>
		<field name="description" type="text" indexed="true" stored="false"/>
		<field name="display_description" type="text" indexed="true" stored="true"/>

		<!-- Identifiers -->
<!--		<field name="lccn" type="string" indexed="true" stored="true" multiValued="true"/>-->
		<field name="oclc" type="string" indexed="true" stored="true" multiValued="true"/>
		<!-- All MARC tags 035a
		 $a - System control number - MARC code (enclosed in parentheses) of the organization originating the system control number, followed immediately by the number.
		 -->
		<field name="primary_isbn" type="textProper" indexed="false" stored="true" multiValued="false"/>
		<field name="isbn" type="textProper" indexed="true" stored="true" multiValued="true"/>
		<field name="issn" type="textProper" indexed="true" stored="true" multiValued="true"/>
		<field name="primary_upc" type="textProper" indexed="false" stored="true" multiValued="false"/>
		<field name="upc" type="textProper" indexed="true" stored="true" multiValued="true"/>

		<!-- Call Numbers -->
		<field name="callnumber-a" type="string" indexed="true" stored="true"/>
		<field name="callnumber-first" type="string" indexed="true" stored="true" docValues="true"/>
		<!-- callnumber-first is populated by translations of the first letter of a Library of Congress style call number.
		099a for a locally assigned free text call number, or then a 090a for locally assigned LC style call numbers,
		or then 050a for the Library of Congress Call Number.
		So TP245.T9, translates "T" to "T - Technology".  This field uses the translation file
		callnumber_map.properties
		 Currently this field only contributes to the KeywordProper search -->

		<field name="callnumber-subject" type="string" indexed="true" stored="true"/>
		<!-- callnumber-subject is populated by translations of the first two letters of a Library of Congress style call number.
		090a for locally assigned LC style call numbers or 050a for the Library of Congress Call Number
		So TP245.T9, translates "TP" to "TP - Chemical Technology".  This field uses the translation file
		callnumber_subject_map.properties
		 Currently this field only contributes to the KeywordProper search -->
		<dynamicField name="local_callnumber_*" type="callnumber-search" indexed="true" stored="true" multiValued="true"/>
		<dynamicField name="local_callnumber_exact_*" type="text-exact" indexed="true" stored="true" multiValued="true"/>
		<dynamicField name="local_callnumber_left_*" type="text-left" indexed="true" stored="true" multiValued="true"/>
		<dynamicField name="callnumber_sort_*" type="text-exact" indexed="true" stored="true" multiValued="false"/>

		<!-- Language Related Fields -->
		<dynamicField name="language_*" type="string" indexed="true" stored="true" multiValued="true" omitNorms="true" docValues="true"/>
		<dynamicField name="translation_*" type="string" indexed="true" stored="true" multiValued="true" omitNorms="true" docValues="true"/>
		<dynamicField name="language_boost_*" type="integer" indexed="true" stored="true" multiValued="false" omitNorms="true"/>
		<dynamicField name="language_boost_es_*" type="integer" indexed="true" stored="true" multiValued="false" omitNorms="true"/>
		<!-- Fields for boosting branch holdings -->
		<dynamicField name="lib_boost_*" type="integer" indexed="true" stored="true" multiValued="false" omitNorms="true"/>
		<!-- relevance determiners -->
		<field name="popularity" type="integer" indexed="true" stored="true" multiValued="false" default="0"/>
		<field name="num_holdings" type="integer" omitNorms="true" indexed="true" stored="true" multiValued="false"/>
		<!-- Fields from Pika Enrichment -->
		<field name="tag" type="string" indexed="true" stored="true" multiValued="true"/>
		<field name="rating" type="float" indexed="true" stored="true" multiValued="false" default="2.5"/>
		<field name="rating_facet" type="string" indexed="true" stored="true" multiValued="true" docValues="true"/>
		<field name="system_list" type="string" indexed="true" stored="true" multiValued="true"/>

		<!-- Special fields for Lists -->
		<field name="num_titles" type="integer" indexed="true" stored="true" multiValued="false"/>

		<!-- Field to get random titles -->
		<dynamicField name="random*" type="random" indexed="true" stored="true"/>

	</fields>
	<uniqueKey>id</uniqueKey>
<!--	<defaultSearchField>keywords</defaultSearchField>
TODO: need to set df parameter?
* Setting <defaultSearchField> in schema is no longer allowed and will cause an exception.
  Please use "df" parameter on the request instead. For more details, see SOLR-10585.
-->
	<!-- CopyFields for Faceting on Text -->
<!--	<copyField source="title_full" dest="title_fullStr"/>-->
	<copyField source="author" dest="authorStr"/>
	<copyField source="author" dest="author_exact"/>
	<copyField source="author" dest="author_left"/>
	<copyField source="auth_author" dest="auth_authorStr"/>
	<copyField source="author2" dest="author2Str"/>
	<copyField source="auth_author2" dest="auth_author2Str"/>
<!--	<copyField source="author_additional" dest="author_additionalStr"/>  Pretty sure this is redundant pascal. 7/19/21-->
<!--	<copyField source="publisher" dest="publisherStr"/>  Pretty sure this is redundant pascal 11/12/20-->
	<!-- CopyFields for Proper (Unstemmed) searching -->
	<copyField source="title" dest="title_proper"/>
	<copyField source="title" dest="title_exact"/>
	<copyField source="title" dest="title_left"/>
	<copyField source="keywords" dest="keywords_proper"/>
	<copyField source="table_of_contents" dest="table_of_contents_proper"/>
	<copyField source="series" dest="series_proper"/>
	<copyField source="topic" dest="topic_proper"/>
	<copyField source="subject_facet" dest="subject"/>
	<copyField source="subject_facet" dest="subject_proper"/>
	<copyField source="geographic" dest="geographic_proper"/>
	<copyField source="era" dest="era_proper"/>
	<copyField source="genre" dest="genre_proper"/>
	<copyField source="local_callnumber_*" dest="local_callnumber_exact_*"/>
	<copyField source="local_callnumber_*" dest="local_callnumber_left_*"/>
</schema>
