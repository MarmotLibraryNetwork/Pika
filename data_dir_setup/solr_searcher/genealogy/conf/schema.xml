<?xml version="1.0" ?>
<schema name="Pika Genealogy Index" version="1.6">
	<!-- attribute "name" is the name of this schema and is only used for display purposes.
	   version="x.y" is Solr's version number for the schema syntax and
	   semantics.  It should not normally be changed by applications.

	   1.0: multiValued attribute did not exist, all fields are multiValued
			by nature
	   1.1: multiValued attribute introduced, false by default
	   1.2: omitTermFreqAndPositions attribute introduced, true by default
			except for text fields.
	   1.3: removed optional field compress feature
	   1.4: autoGeneratePhraseQueries attribute introduced to drive QueryParser
			behavior when a single string produces multiple tokens.  Defaults
			to off for version >= 1.4
	   1.5: omitNorms defaults to true for primitive field types
			(int, float, boolean, string...)
	   1.6: useDocValuesAsStored defaults to true.
	-->

	<types>
		<!-- Valid attributes for fields:
		 name: mandatory - the name for the field
		 type: mandatory - the name of a field type from the
		   fieldTypes section
		 indexed: true if this field should be indexed (searchable or sortable)
		 stored: true if this field should be retrievable
		 docValues: true if this field should have doc values. Doc Values is
		   recommended (required, if you are using *Point fields) for faceting,
		   grouping, sorting and function queries. Doc Values will make the index
		   faster to load, more NRT-friendly and more memory-efficient.
		   They are currently only supported by StrField, UUIDField, all
		   *PointFields, and depending on the field type, they might require
		   the field to be single-valued, be required or have a default value
		   (check the documentation of the field type you're interested in for
		   more information)
		 multiValued: true if this field may contain multiple values per document
		 omitNorms: (expert) set to true to omit the norms associated with
		   this field (this disables length normalization and index-time
		   boosting for the field, and saves some memory).  Only full-text
		   fields or fields that need an index-time boost need norms.
		   Norms are omitted for primitive (non-analyzed) types by default.
		 termVectors: [false] set to true to store the term vector for a
		   given field.
		   When using MoreLikeThis, fields used for similarity should be
		   stored for best performance.
		 termPositions: Store position information with the term vector.
		   This will increase storage costs.
		 termOffsets: Store offset information with the term vector. This
		   will increase storage costs.
		 required: The field is required.  It will throw an error if the
		   value does not exist
		 default: a value that should be used if no value is specified
		   when adding a document.
		-->

		<!-- field names should consist of alphanumeric or underscore characters only and
		  not start with a digit.  This is not currently strictly enforced,
		  but other field names will not have first class support from all components
		  and back compatibility is not guaranteed.  Names with both leading and
		  trailing underscores (e.g. _version_) are reserved.
		-->


		<fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true" docValues="true"/>
		<fieldType name="integer" class="solr.IntPointField" omitNorms="true" docValues="true"/>
		<fieldType name="long" class="solr.LongPointField" positionIncrementGap="0" docValues="true"/>
		<fieldType name="date" class="solr.DatePointField" docValues="true"/>
		<fieldType name="textFacet" class="solr.TextField" sortMissingLast="true" omitNorms="true">
			<analyzer>
				<tokenizer class="solr.KeywordTokenizerFactory"/>
				<!-- strip trailing punctuation from facets: -->
				<filter class="solr.PatternReplaceFilterFactory" pattern="(?&lt;!\b[A-Z])[.\s]*$" replacement="" replace="first"/>
			</analyzer>
		</fieldType>
		<fieldType name="text" class="solr.TextField" positionIncrementGap="100">
			<analyzer type="index">
				<tokenizer class="solr.WhitespaceTokenizerFactory"/>
				<filter class="solr.WordDelimiterGraphFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"  splitOnNumerics="0" stemEnglishPossessive="1"/>
				<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
				<filter class="solr.LowerCaseFilterFactory"/>
				<filter class="solr.SnowballPorterFilterFactory" language="English" protected="protwords.txt"/>
				<filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
				<filter class="solr.ICUFoldingFilterFactory"/>
				<!-- ICU Tokenizer requires additional library to be added in the core's /lib folder to work.
				  https://lucene.apache.org/solr/guide/7_7/tokenizers.html#tokenizers
				  -->
			</analyzer>
			<analyzer type="query">
				<tokenizer class="solr.WhitespaceTokenizerFactory"/>
				<filter class="solr.SynonymGraphFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
				<filter class="solr.WordDelimiterGraphFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1" splitOnNumerics="0" stemEnglishPossessive="1"/>
				<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
				<filter class="solr.LowerCaseFilterFactory"/>
				<filter class="solr.SnowballPorterFilterFactory" language="English" protected="protwords.txt"/>
				<filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
				<filter class="solr.ICUFoldingFilterFactory"/>
			</analyzer>
		</fieldType>
		<!-- Text Field without Stemming and Synonyms -->
		<fieldType name="textProper" class="solr.TextField" positionIncrementGap="100">
			<analyzer type="index">
				<tokenizer class="solr.ICUTokenizerFactory"/>
				<filter class="solr.ICUFoldingFilterFactory"/>
				<filter class="solr.WordDelimiterGraphFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnNumerics="0" stemEnglishPossessive="1"/>
				<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
				<filter class="solr.LowerCaseFilterFactory"/>
				<filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
			</analyzer>
			<analyzer type="query">
				<tokenizer class="solr.WhitespaceTokenizerFactory"/>
				<filter class="solr.ICUFoldingFilterFactory"/>
				<filter class="solr.WordDelimiterGraphFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnNumerics="0" stemEnglishPossessive="1"/>
				<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
				<filter class="solr.LowerCaseFilterFactory"/>
				<filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
			</analyzer>
		</fieldType>
		<!-- Basic Text Field for use with Spell Correction -->
		<fieldType name="textSpell" class="solr.TextField" positionIncrementGap="100">
			<analyzer>
				<tokenizer class="solr.ICUTokenizerFactory"/>
				<filter class="solr.ICUFoldingFilterFactory"/>
				<filter class="solr.WordDelimiterGraphFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0"/>
				<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
				<filter class="solr.LowerCaseFilterFactory"/>
				<filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
			</analyzer>
		</fieldType>
		<!-- More advanced spell checking field. -->
		<fieldType name="textSpellShingle" class="solr.TextField" positionIncrementGap="100">
			<analyzer type="index">
				<tokenizer class="solr.StandardTokenizerFactory"/>
				<filter class="solr.LowerCaseFilterFactory"/>
				<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
				<filter class="solr.ShingleFilterFactory" maxShingleSize="2" outputUnigrams="false"/>
				<filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
			</analyzer>
			<analyzer type="query">
				<tokenizer class="solr.StandardTokenizerFactory"/>
				<filter class="solr.LowerCaseFilterFactory"/>
				<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
				<filter class="solr.ShingleFilterFactory" maxShingleSize="2" outputUnigrams="false"/>
				<filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
			</analyzer>
		</fieldType>
		<!-- This is an example of using the KeywordTokenizer along
				 With various TokenFilterFactories to produce a sortable field
				 that does not include some properties of the source text
			-->
		<fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
			<analyzer>
				<!-- KeywordTokenizer does no actual tokenizing, so the entire
						 input string is preserved as a single token
					-->
				<tokenizer class="solr.KeywordTokenizerFactory"/>
				<!-- The LowerCase TokenFilter does what you expect, which can be
						 when you want your sorting to be case insensitive
					-->
				<filter class="solr.LowerCaseFilterFactory" />
				<!-- The TrimFilter removes any leading or trailing whitespace -->
				<filter class="solr.TrimFilterFactory" />
				<!-- The PatternReplaceFilter gives you the flexibility to use
						 Java Regular expression to replace any sequence of characters
						 matching a pattern with an arbitrary replacement string,
						 which may include back references to portions of the original
						 string matched by the pattern.

						 See the Java Regular Expression documentation for more
						 information on pattern and replacement string syntax.

						 http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/package-summary.html
					-->
				<filter class="solr.PatternReplaceFilterFactory" pattern="([^a-z])" replacement="" replace="all" />
				<fieldType name="random" class="solr.RandomSortField" />
			</analyzer>
		</fieldType>
	</types>
	<fields>
		<field name="_version_" type="long" indexed="false" stored="false"/>
		<!-- docValues are enabled by default for long type so we don't need to index the version field  -->

		<!-- Core Fields  -->
		<field name="id" type="string" indexed="true" stored="true"/>
		<field name="shortId" type="integer" indexed="true" stored="true"/>
		<field name="recordtype" type="string" indexed="true" stored="true"/>

		<field name="title" type="text" indexed="true" stored="true"/>
		<field name="comments" type="text" indexed="true" stored="true"/>
		<field name="keywords" type="text" indexed="true" stored="false"/>

		<!-- Fields Specific to People -->
		<field name="firstName" type="text" indexed="true" stored="true"/>
		<field name="lastName" type="text" indexed="true" stored="true"/>
		<field name="middleName" type="text" indexed="true" stored="true"/>
		<field name="maidenName" type="text" indexed="true" stored="true"/>
		<field name="otherName" type="text" indexed="true" stored="true"/>
		<field name="nickName" type="text" indexed="true" stored="true"/>
		<field name="fullName" type="text" indexed="true" stored="true"/>
		<field name="veteranOf" type="textFacet" indexed="true" stored="true" multiValued="true"/>
		<field name="birthDate" type="date" indexed="true" stored="true" multiValued="false"/>
		<field name="deathDate" type="date" indexed="true" stored="trues" multiValued="false"/>
		<field name="birthYear" type="string" indexed="true" stored="true" multiValued="false"/>
		<field name="deathYear" type="string" indexed="true" stored="true" multiValued="false"/>
		<field name="ageAtDeath" type="text" indexed="true" stored="true" multiValued="false"/>
		<field name="cemeteryName" type="textFacet" indexed="true" stored="true"/>
		<field name="cemeteryLocation" type="textFacet" indexed="true" stored="true"/>
		<field name="mortuaryName" type="textFacet" indexed="true" stored="true"/>
		<field name="sex" type="textFacet" indexed="true" stored="true"/>
		<field name="race" type="textFacet" indexed="true" stored="true"/>
		<field name="causeOfDeath" type="textFacet" indexed="true" stored="true"/>

		<!-- Fields Specific to Obituaries -->
		<field name="obituaryDate" type="date" indexed="true" stored="true" multiValued="true"/>
		<field name="obituarySource" type="textFacet" indexed="true" stored="true" multiValued="true"/>
		<field name="obituaryText" type="text" indexed="true" stored="true" multiValued="true"/>

		<!-- Fields Specific to Marriages -->
		<field name="spouseName" type="string" indexed="true" stored="true" multiValued="true"/>
		<field name="marriageDate" type="date" indexed="true" stored="true" multiValued="true"/>
		<field name="marriageComments" type="text" indexed="true" stored="true" multiValued="true"/>

		<!-- Fields Specific to Artifacts -->
<!-- TODO: all of these fields are obsolete
		<field name="catalogId" type="string" indexed="true" stored="true"/>
		<field name="objectName" type="string" indexed="true" stored="true"/>
		<field name="catalogType" type="string" indexed="true" stored="true"/>
		<field name="dateOfCreation" type="date" indexed="true" stored="true" multiValued="false"/>
		<field name="dateOfAcquisition" type="date" indexed="true" stored="true" multiValued="false"/>
		<field name="physicalDescription" type="string" indexed="true" stored="true"/>
		<field name="place" type="string" indexed="true" stored="true"/>
		<field name="copyright" type="string" indexed="true" stored="true"/>
		<field name="collection" type="string" indexed="true" stored="true"/>
		<field name="lexiconCategory" type="string" indexed="true" stored="true"/>
		<field name="lexiconSubCategory" type="string" indexed="true" stored="true"/>
		<field name="subjects" type="string" indexed="true" stored="true" multiValued="false"/>
-->

		<!-- Spelling -->
        <field name="spelling" type="textSpell" indexed="true" stored="true"/>
		<field name="spellingShingle" type="textSpellShingle" indexed="true" stored="true" multiValued="true"/>

    </fields>
	<uniqueKey>id</uniqueKey>
<!--	<defaultSearchField>keywords</defaultSearchField>
TODO: need to set df parameter?
* Setting <defaultSearchField> in schema is no longer allowed and will cause an exception.
  Please use "df" parameter on the request instead. For more details, see SOLR-10585.
-->

	<!-- CopyFields for Spelling -->
	<!-- ** Basic, single word spelling -->
	<copyField source="keywords" dest="spelling"/>

	<!-- Default Boolean Operator -->
<!--	<solrQueryParser defaultOperator="AND"/>
obsolete now.
TODO: how does this affect our queries?? -->
</schema>
